"""
Helpers for using SynQc Temporal Dynamics from Jupyter notebooks.

These utilities sit on top of synqc_live.runtime and are safe to ignore
for non-notebook environments.
"""

from __future__ import annotations

from typing import Tuple

import matplotlib.pyplot as plt
import pandas as pd

from .config import SynQcConfig
from .runtime import PipelineResult, build_quickstart_config, run_pipeline


def quickstart_demo(
    *,
    num_iterations: int = 5,
    plot: bool = True,
) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """
    Run a quickstart SynQc experiment and optionally plot the results.

    Parameters
    ----------
    num_iterations:
        Number of adaptive iterations to execute.
    plot:
        If True, emit simple matplotlib plots for the iteration trace
        and the adaptive loop.

    Returns
    -------
    (iteration_df, adaptive_df)
        iteration_df: per-sample DataFrame from a single iteration.
        adaptive_df: per-iteration DataFrame from the adaptive loop.
    """
    cfg = build_quickstart_config()
    result: PipelineResult = run_pipeline(cfg, num_iterations=num_iterations, run_adaptive=True)

    iter_df = result.iteration
    adapt_df = result.adaptive if result.adaptive is not None else pd.DataFrame()

    if plot:
        _plot_quickstart(cfg, iter_df, adapt_df)

    return iter_df, adapt_df


def _plot_quickstart(
    config: SynQcConfig,
    iter_df: pd.DataFrame,
    adapt_df: pd.DataFrame,
) -> None:
    """
    Minimal plotting helper for the quickstart demo.

    Assumes the standard columns generated by the live engine.
    """
    fig, axes = plt.subplots(2, 1, figsize=(8, 6))

    # Top: amplitude vs time from the single iteration
    if {"t_ns", "amplitude"}.issubset(iter_df.columns):
        axes[0].plot(iter_df["t_ns"], iter_df["amplitude"])
        axes[0].set_xlabel("t (ns)")
        axes[0].set_ylabel("amplitude")
        axes[0].set_title("Probe amplitude vs time (single iteration)")
    else:
        axes[0].text(
            0.5,
            0.5,
            "Iteration DataFrame missing 't_ns'/'amplitude'",
            ha="center",
            va="center",
            transform=axes[0].transAxes,
        )

    # Bottom: adaptive loop convergence
    if not adapt_df.empty and {"iteration", "avg_probe_amplitude"}.issubset(adapt_df.columns):
        axes[1].plot(adapt_df["iteration"], adapt_df["avg_probe_amplitude"])
        axes[1].axhline(
            getattr(config, "target_amplitude", 1.0),
            linestyle="--",
            label="target",
        )
        axes[1].set_xlabel("iteration")
        axes[1].set_ylabel("avg probe amplitude")
        axes[1].set_title("Adaptive loop convergence")
        axes[1].legend()
    else:
        axes[1].text(
            0.5,
            0.5,
            "Adaptive DataFrame empty or missing expected columns",
            ha="center",
            va="center",
            transform=axes[1].transAxes,
        )

    fig.tight_layout()
    plt.show()
